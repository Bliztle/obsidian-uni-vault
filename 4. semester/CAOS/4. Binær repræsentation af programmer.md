- CSPP3 Kapitel 3- (s 236-249)
- CSPP3 Afsnit 3.6.6 (s. 250-254: 5 pages), kan evt. udskydes til lektion 7  
- CSPP3 Kapitel 3 (s. 256-264)
- CSPP3 Kapitel 3 (s 291--301)

## Control
#cspp/3-6

#### Condition codes
Bit flags with information from the most recent instructions
*`leaq` does not modify these*

| Flag | Description                                                                         |
| ---- | ----------------------------------------------------------------------------------- |
| `CF` | Carry flag<br>*detects unsigned overflows*<br>Carry out of the most significant bit |
| `ZF` | Zero flag<br>Operation yielded 0                                                    |
| `SF` | Sign flag<br>Operation yielded negative result                                      |
| `OF` | Overflow flag<br>*detects signed overflow*<br>Most significant bit was set to 1     |
###### Using condition codes
*not commonly checked directly*
1. Set a single bite 0 or 1
2. conditional jumping
3. conditional data transfer

#### Conditional move `cmov`
Instead of jumping to different addresses for control flow, it may be more efficient to compute both values and conditionally return

Suitable for ternary assignments, translating to
```c
v = then_expr;
ve = else_expr;
t = test_expr;
if (!t) v = ve;
```
doesn't work if `{c}then_expr` or `{c}else_expr` can have side effects, like derefferencing a null pointer.
###### Example: Absolute Difference
![](Pasted%20image%2020240227181451.png)
here it is faster to calculate the difference both ways and `cmovge` than comparing, branching, and returning.

CPU's pipeline operations, but that is hard for jumps, as the next operations are unknown
- Predictions aim to be 90% accurate, but depends on the context. This is ~50/50

> The branching pattern is easily predictable, and around 17.50 clock cycles per call when the branching pattern is random. From this, we can infer that the branch misprediction penalty is around 19 clock cycles
> - #cspp/3-6-6 

Completion times in the example ranged from 8-27 cycles.

#### Loops
Do-while takes the form
```c
loop:
	body_expr
	t = test_expr;
	if (t)
		goto loop;
```

while has two options, the second one more optimised, as initial condition can be optimised by compiler or pipelined by CPU
```c
	goto test;
loop:
	body_expr
test:
	t = test_expr;
	if (t)
		goto loop;
```
```c
t = test_expr
if (!t)
	goto done;
loop:
	body_expr
	t = test_expr
	if (t)
		goto loop;
```

## Array allocation and access
Allocates $n\cdot s$ bytes, where $n$ is length and $s$ is element size.

#### Expressions and assembly representation
![](Pasted%20image%2020240227185127.png)
###### Nested arrays
*not pointers to pointers*
Stored as a single array, calculating offsets

For multidimensional (write time) fixed size arrays, calculations can be optimised with pointer arithmetic. 
![](Pasted%20image%2020240227185745.png)
Matrix calculation doesn't loop indexes, but instead changes the pointer each iteration. Assembly is directly translated.