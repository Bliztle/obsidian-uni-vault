## Exceptional Control Flow
#cspp/8
*Flow of control* / *control flow* is a sequence $a_{0}, a_{1},\dots, a_{n-1}$ of *control transfers* $a_{n-1}\rightarrow a_{n}$ changing the address of the program counter #PC
- *Smooth* transitions increment to neighbouring instruction address
*Exceptional control flow* #ECF are transfers interrupting the current execution
- Incoming network request, hardware clock interval, sleeping.
- Happens at all levels. Hardware, OS, Runtime, Application code, metaphorically the developers operating in a different pattern
#### Exceptions
#cspp/8-1 *abrupt change in control flow, in response to change in processor state*
partly implemented in hardware, partly in OS.
- Change in state is an *event*
- On *event*, indirect call is made through through jump table *exception table* to *exception handler* (OS subrutine)
- One of 3 results
	1. Handler returns control to current instruction $I_{curr}$
	2. Handler returns control to next instruction $I_{next}$
	3. Handler aborts the interrupted program
![](Pasted%20image%2020240409165323.png)

Each unique type of exception is assigned an *exception number (uint)*. Some by designer of #CPU, others by designers of OS #kernel.
- *exception table* assigned on boot. Trap part may be referenced as *trap table* #ostep/6/2
- start is *exception table base register*
![](Pasted%20image%2020240409165705.png)
Differences from procedure call:
- Current address is pushed on stack, but may be next instruction instead
- Additional information is pushed, like #x86-64 EFLAGS register
- If control is transfered to #kernel, it is instead pushed to #kernel stack
- Handlers run in #kernel mode, with full system access.
After trigger, rest is handled by software
###### Classes of Exceptions
#cspp/8-1-2
![](Pasted%20image%2020240409170130.png)
The triggering exception is the *faulting exception* (but not necessarily a *fault* exception)
Handling an exception:
![](Pasted%20image%2020240409170401.png) ![](Pasted%20image%2020240409170811.png)
- *Interrupt* - see figure 8.5
- *Trap* - making a system call and passing control to #kernel. Fx `read`, `fork` (new process), `execve` (`exec` on #UNIX #ostep/4) or `exit`.
	- Done with `syscall n` where `n` indicates which instruction
- *Fault* - Fx *page fault exception*, where virtual address referenced is not in a loaded page, and must be fetched from desk #SWAP 
	- Paging is fx because programs are loaded lazily, so not all is read initially from disk.
- *Abort* - Unrecoverable, fatal errors, such as #DRAM #SRAM bits being corrupted
###### Linux / x86-64 exceptions
#cspp/8-1-3 #linux #x86-64
![](Pasted%20image%2020240409171142.png) ![](Pasted%20image%2020240409171056.png)
System calls
*syscalls* or *system-level functions*
![](Pasted%20image%2020240409171310.png)
All arguments on #linux are passed with syscall number on `%rax` and args on `%rdi - %r9` in order
#### Processes
#cspp/8/2 *an instance of a program in execution*
- Intedepent control flow
- Private address space
###### Logical control flow
#cspp/8/2/1
![](Pasted%20image%2020240409172057.png)
Process being temporarily suspended is *preempted*
#concurrency is processes running at the same time. BC does not, as B completes before C starts.
- *time slicing* divides cpu time
#parallel flows are running at the same time on different CPUs, without *time slicing* each other.
![](Pasted%20image%2020240409175107.png) ![](Pasted%20image%2020240409175142.png)
#ostep/4 Process states are running / ready / blocked
###### Private Address Space
begins at `0x400000` above which is kernel code
![](Pasted%20image%2020240409172537.png)
*mode bit* on means running in #kernel mode, with all privileges.
on #linux, kernel info is in `/proc/*process-id*`
###### Context Switches
#cspp/8/2/5 *higher level exceptional control flow for context switching*
- *preempting* decisions are made by *scheduler* doing *context switching*
	1. Save current context
	2. restore save context of previous process
	3. pass control to restored process
![](Pasted%20image%2020240409173331.png)
#### Execution
#ostep/6 
Problems:
1. Restricted operations (i.e. I/O)
	1. Solved with limited direct execution
2. Switching between processes
	1. Give OS with scheduler control. OS has timed interval interrupt where it takes control in exception table, and decides course.
###### Direct execution
#ostep/6/1 *directly executing on the cpu*
![](Pasted%20image%2020240409183709.png)
Cannot perform restricted operations (i.e. I/O)
###### Limited direct execution
#ostep/6/2 
![](Pasted%20image%2020240409184258.png)
###### Timer interrupt
![](Pasted%20image%2020240409184558.png)
###### Concurrency
#ostep/6/4 *what if timer interrupt happens during a syscall (i.e. interrupt in interrupt)*
lock / queue, or system might simply disable during interrupts (though dangerous).