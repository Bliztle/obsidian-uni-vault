## Preparation
#### Exercise 1.
![](Pasted%20image%2020240319203241.png)
- Create `ftable` with `Get_funs`
	- get $(f, t)$ of `f` with `Get_fun`
	- recursive `Get_funs`
		- get $(f,t)$ of main with `Get_fun`
		- bind to `emptytable`
	- bind to `ftable` with main already in
- check functions in `ftable`
	- recursively check each function
		- check `f`
			- get $(f, t_{0})$ of `f`
			- create `vtable` with `int x` from checking argument type ids
			- get $t_{1}$ from checking expression with `ftable` & `vtable`
				- check plus expression
					- get $t_{1}$ from checking first expression
						- lookup x to get type
						- it is not unbound, so no error
					- get $t_{2}$ from checking second expression
						- It is a literal num, so int
					- compare types, return int on success
			- compare $t_{0}==t_{1}$ checking expression type with return type
			- No error, they are compatible
		- check `main`
			- get $(f, t_{0})$ of `main`
			- get empty `vtable`. Technically not supported with no arguments, but we let it slide
			- get $t_{1}$ from checking expression with `ftable` & `vtable`
				- check function call `f`
					- get $t$ from lookup on `f` in `ftable`
						- it is not unbound
					- get arguments $t_{1},\dots,t_{n}$ and return type $t_{0}$ from $t$
					- check each given expression against argument
						- 5 matches the int x
					- return $t_{0}$
			- They match, hurray
#### Exercise 2.
![](Pasted%20image%2020240319203249.png)
To check arguments and return types match with expressions