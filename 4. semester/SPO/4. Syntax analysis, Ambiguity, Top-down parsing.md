- To be able to explain the definition of a context-free grammar
	- A recursive definition of a set if nonterminals
- To be able to explain the notion of ambiguity and why it is important
	- Derivation may have multiple options or possible order of operations, leading to different syntax trees if not fixed
- To be able to reason about operator precedence and to describe precedence in a context-free grammar
	- See operator precedence below
- To be able to apply techniques for removing ambiguity in a context-free grammar
	- See operator precedence below
- To be able to explain the FIRST and FOLLOW sets and the NULLABLE predicate and their role in an LL parser
	- They are important for deciding which production(s) match
- To be able to understand and carry out the steps of an LL(1) parser
	- See code below
- To be able to apply left factorisation and removal of left recursion and to be able to explain why these techniques are important
#itcd/2

## Context-Free Grammars
#itcd/2-1 *What is is and when to use it*
![](Pasted%20image%2020240228220325.png)

| Term              | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Terminal          | A symbol in an alphabet                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Nonterminal       | a set of strings recursively defined in context-free grammar<br><br>*Disjoint* from terminals                                                                                                                                                                                                                                                                                                                                                                                                |
| Start symbol      | Nonterminal denoting "the main language described by the grammar"                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Production        | Each production describes some of the possible strings contained in a nonterminal.<br><br>Has form:<br>$N\rightarrow X_{1}\dots X_{n}$<br>- $N$ is a nonterminal<br>- $X_{1}\dots X_{n}$  are 0 or more symbols, which are either terminals or nonterminals<br><br>In the book, $N$ is a set of a single string of a single symbol.<br>- $A\rightarrow \texttt{a}$ means the nonterminal of the single one-symbol string $\texttt{a}$<br>- $A\rightarrow \texttt{a}A$ is regex $\texttt{a}+$ |
| Empty Productions | $B\rightarrow$                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |

###### Non regular languages
grammar can describe non-regular languages

$a^{n}b^{n}|n\geq0$ becomes
	$S\rightarrow$
	$S\rightarrow \texttt{a}S\texttt{b}$

###### Multiple nonterminals
First nonterminal is start

| Notation                  | Nonterminals                                                                                                        | Extra Symbols |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------- | ------------- |
| Normal                    | $T\rightarrow R$<br>$T\rightarrow \texttt{a}T\texttt{a}$<br>$R\rightarrow \texttt{b}$<br>$R\rightarrow \texttt{b}R$ |               |
| Extended                  | $T\rightarrow R \mid \texttt{a}T\texttt{a}$<br>$R\rightarrow \texttt{b}\mid\texttt{b}R$                             | $\mid$        |
| Extended Backus-Naur Form | $T\rightarrow \texttt{b}^+ \mid \texttt{a}T\texttt{a}$                                                              | $\mid?^{+*}$  |
#### Syntactic Categories

|              | Description                                                                                                                                    |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| Expressions  | are used to express calculation of values.                                                                                                     |
| Statements   | express actions that occur in a particular sequen                                                                                              |
| Declarations | define properties of named entities such as variables or functions used in other parts of the program                                          |
| Types        | are used in declarations to limit the kinds of values a variable can have or the parameters a function can take and the results it can return. |
## Derivation
#itcd/2-2 *Considering products as rewrite rules*
1. $\alpha N\beta\Rightarrow\alpha\gamma\beta$ if $N\rightarrow\gamma$
2. $\alpha\Rightarrow\alpha$
3. $\alpha\Rightarrow\gamma$ if $\exists\beta\ .\alpha\Rightarrow\beta\land\beta\Rightarrow\gamma$
Derivation is reflexive and transitive, by $2, 3$
*Rightmost* and *leftmost* derivatives are those which always rewrite the rightmost or leftmost nonterminals.

#### Syntax Trees and Ambiguity
#itcd/2-2-1 *Drawing derivations as trees*
left- and right-most derivation gives the same tree, but ambiguity matters for parsing text
- Parsing is reverse derivation
![](Pasted%20image%2020240227210210.png)
Ambiguity is undecidable
-  No one algorithm determines ambiguity
## Operator Precedence
#itcd/2-3 *Fixing ambiguity*

| Associativity for infix operators | Rule                           |
| --------------------------------- | ------------------------------ |
| left-associate                    | $(a\oplus b)\oplus c$          |
| right-associative                 | $a\oplus(b\oplus c)$           |
| non-associative                   | $a\oplus b\oplus c$ is illegal |
Rewriting to recursion instead of ambiguity

| Ambigous                                                | Left-recursive                                                                | Right-recursive                                                               | Non-recursive                                                                  |
| ------------------------------------------------------- | ----------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| $E\rightarrow E\oplus E$<br>$E\rightarrow \textbf{num}$ | $E\rightarrow E\oplus E'$<br>$E\rightarrow E'$<br>$E\rightarrow \textbf{num}$ | $E\rightarrow E'\oplus E$<br>$E\rightarrow E'$<br>$E\rightarrow \textbf{num}$ | $E\rightarrow E'\oplus E'$<br>$E\rightarrow E'$<br>$E\rightarrow \textbf{num}$ |
Expressions can only define operations with the same precedence level, leading to multiple expressions. Those can then be gathered in one when reducing the tree.
![](Pasted%20image%2020240228221930.png)

## Parsing methods

#### Predictive parsing
#itcd/2-6 *deterministic top-down parsing*
Using unambigous left-derivation with built-in operator precedence, starting from an end.
Always choose either the terminal matching next symbol, or the one nonterminal starting with a nonterminal
- There can never be more than one option for this

Alternatively pick $N\rightarrow\alpha$ if either
1. $c\in FIRST(\alpha)$
2. $Nullable(\alpha)$ and the sequence $Nc$ can occur in a derivation from the start symbol

Not perfect. Can still fail in 3 cases
![](Pasted%20image%2020240227233621.png)
#### _Nullable_ and _FIRST_
#itcd/2-7 *When there are more than one nonterminal to choose*
1. If predictive parsing is available, do that
2. Otherwise, find the set of strings each production can derive
3. find set of first characters for these sets of strings
	1. These are the *FIRST* sets of the productions
	2. If they are disjoint, pick one that matches
	3. If there is an empty production, pick that
	4. Otherwise, report syntax error
#### The *FIRST* functions
#itcd/definition/2-2

In short:

$FISRT(\alpha)=\{c\in\Sigma|\exists_{\beta\in(\Sigma\cup N)^{*}} \text{ where }\alpha\Rightarrow^{*}c\beta\}$

Written in cases:

$\begin{align}&FIRST(\alpha)&=&c\Leftrightarrow(\alpha\Rightarrow c\beta)\\&FIRST(N\rightarrow \alpha)&=&FIRST(\alpha)\\&FIRST(N)&=&\bigcup\limits_{i=1}^{n}FIRST(N\rightarrow\alpha_{i})\end{align}$

To calculate first, a function $Nullable$ is needed. A sequence is nullable if it can derive the empty string
#itcd/definition/2-2 #itcd/algorithm/2-4 

$\begin{align}&Nullable()&=&true\\&Nullable(\texttt{a})&=&false\\&Nullable(\alpha\beta)&=&Nullable(\alpha)\land Nullable(\beta)\\&Nullable(N)&=&Nullable(\alpha_{1})\lor\dots\lor Nullable(\alpha_{i})\\\end{align}$

This can produce a set of boolean equations much like set equations
- Monotonic and distributive. $F(\dots(p\lor q)\dots)=F(\dots p\dots)\lor(\dots q\dots)$

$\begin{align}X_{1}&=F_{1}(X_{1},\dots X_{n})\\&\ \ \vdots\\X_{n}&=F_{n}(X_{1},\dots X_{n})\\\end{align}$

Assume all to be false, then iterate until there are no changes
###### Example
![](Pasted%20image%2020240227232246.png)
![](Pasted%20image%2020240227232355.png)
From there, it is easy to plug in values
![](Pasted%20image%2020240227232636.png)

###### The Actual *FIRST* Algorithm
#itcd/algorithm/2-5 
![](Pasted%20image%2020240227232746.png)
## Follow
#itcd/2-9 *Determining when we can pick a nullable production in predictive parsing*

> Terminal $c$ is in $FOLLOW(N)$ is $c$ may follow $N$ at some point in the derivation.
> Unlike $FIRST(N)$, this is not a property of the productions for $N$, but of the productions that (directly or indirectly) use $N$ on their right-hand side.

End-of-string is handled by adding a production
- $S'\rightarrow S\$$
	-  $(\$\in FOLLOW(N))\Leftrightarrow(S'\Rightarrow\alpha N\$)\Leftrightarrow(S\Rightarrow\alpha N)$

#### Calculating FOLLOW
#itcd/2-9 p. 64 *creating and solving set constraints*

For: $M\rightarrow\alpha N\beta$ 
1. $FIRST(\beta)\subseteq FOLLOW(N)$
2. $Nullable(\beta)\rightarrow FOLLOW(M)\subseteq FOLLOW(N)$

Order of calculation
1. Add $S'\rightarrow S$ to grammer
2. Find set constraints
3. Solve steps:
	1. Start with $FOLLOW(N)=Ø$ for all $N$
	2. Add all $m\subseteq Follow(N)$ to $FOLLOW(N)$
		1. These are the $FIRST(\beta)\subseteq FOLLOW(N)$
	3. Add all $FOLLOW(M)\subseteq FOLLOW(N)$
		1. Iterate here til fixed point is reached
## LL(1) Parsing
#itcd/2-11 
LL(1) parsing describes parsing where we can always choose a unique production $N\rightarrow\alpha$ on symbol $c$ if either
1. $c\in FIRSTS(\alpha)$ or
2. $Nullable(\alpha)\land c\in FOLLOW(N)$

Also written as
$La(N\rightarrow\alpha_{1})\cap La(N\rightarrow\alpha_{2})=Ø$

![](Pasted%20image%2020240228215547.png)
#### Recursive descent
#itcd/2-11-1
Functions chain-calling each other recursively.
- If $c$ is first, choose that production
- Otherwise if $Nullable(\alpha)$, check for $c\in FOLLOW(N)$
- Lastly report error if no match
![](Pasted%20image%2020240228211802.png)

Another example
![](Pasted%20image%2020240228224424.png)

#### Table-Driven LL(1) Parsing
*encode productions into a table and runs with a stack*
Create a table with $N\rightarrow \alpha$ in position $(N,\texttt{c})$ if either condition matches.
Stack consists of terminals and nonterminals.
![](Pasted%20image%2020240228213321.png)
#### Conflicts
There exist unambiguous grammars which have conflicts.
- These are non-LL(1) grammars
- Different from non-LL(1) languages
- Can sometimes be rewritten

## Rewriting Grammar for LL(1) Parsing
#itcd/2-12*Left-factorisation and elimination of left-recursion*

![](Pasted%20image%2020240228214928.png)
is equivalent to
![](Pasted%20image%2020240228214953.png)
is equivalent to
![](Pasted%20image%2020240228215006.png)
This may change the syntax tree and require restructuring
###### Indirect left recursion
![](Pasted%20image%2020240228215139.png)
Rewriting is hard. page 75 links to a procedure.

#### Left-factorisation
Conflicts with common $FIRST(\alpha)$ can often be solved by grouping the common part in another production, which points to the original ones.