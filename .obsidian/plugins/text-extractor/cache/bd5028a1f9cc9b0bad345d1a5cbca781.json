{"path":"4. semester/SPO/attachments/Pasted image 20240313163535.png","text":"Evalgy(Exp, vtable. ftable) = case Exp of num | gemalue(num) id v = lookup(viable, gemamelid)) if v =unbound then error() else v Ex+ Ex> vi = Evalgy(Exp, . vtable, ftable) v> = Evalpy (Exp,, vtable, ftable) if vi and vy both are integers then vi +v2 else error0) Ep<Ep |v = Evalpg(Exp,. viable, frable) vz = Evalgy (Exp,. viable. fable) if vj and vy both are integers then if vy < v2 then true else false else if vi and vy both are booleans then if v = false then v, else false else error() if Expy vi = Evalgy(Exp;, viable, fiable) thenEw, | if vi isa boolean elseEw, | then if v =true then Evalgyy(Exp,., viable, fiable) else Evalpy(Exps, viable, fiable) else error() id(Ews) — |def=lookup(ftable, gemame(id)) if def = unbound then error() else args = Evalp;(Exps, vtable, fiable) Callrj(def, args. frable) let id = Ewp, | v = Evaliy (Exp,, vtable, fable) in Exp, viable' = bind(viable, gemame(id), r1) Evalgg(Exp», viable', fiable) Evalgs(Exps, viable fable) = case Exps of Exp | [Evalg(Exp, viable. fiable)] Exp , Exps | Evalz(Exp, vtable, frable) : Evalg(Exps, viable, frable)","libVersion":"0.3.2","langs":"dan+eng"}