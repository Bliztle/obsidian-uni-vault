{"path":"4. semester/SPO/attachments/Pasted image 20240403191419.png","text":"Transpy(Exp,vtable.frable place) = case Exp of true |[place:= I] false | [place := 0] Cond = | label, = newlabel() labely = newlabel() code; = Transcona(Cond,label: labels, vtable. frable) [place := 0]++code, ++[LABEL label;, place := 1] “++[LABEL labeh] Transcma(Cond,label, label . viable.fiable) = case Cond of ExpyrelopExp, | 1y = nenvar() 1 = newvar() codey = Transpsp(Exp, . viable. fiable. 1) code; = Transiy (Expy. viable. fiable. 1) op = transop(getopname(relop)) coder++codes++[IF y op 1y THEN label, ELSE labely] true | 1070 label] false | (6070 label;] Y Cond, | Transcona(Cond) labely,label, vtable.ftable) Condy &s Cond> | arg, = newlabel() codey=Transcyy(Condy ,arg»,labely, viable.ftable) coder=Transcyna(Cond»,label, label ; vtable. frable) codey ++[LABEL arg»]++code, Condy || Cond> | arg, = newlabel() codey=Transcyg(Condy, label, ,arg> viable. fiable) coder=Transcyng(Cond»,label, label , vrable frable) code;++LABEL arg»]++codez Ew 1 = newvar() code; = Transr(Exp, viable. frable,t) codey++[1 I 0 THEN label, ELSE label;] Fig. 6.10 Translation of sequential logical operators","libVersion":"0.3.2","langs":"dan+eng"}