{"path":"4. semester/SPO/attachments/Pasted image 20240319211140.png","text":"Fig.5.2 Type checking of Checkep (Exp. table.flable) = case Exp of expressions o e ia 1= lookup(vtable, gemame(id)) if 1= unbound then error(); int else I Ep,+Ep |1 = Checkep(Exp, vtable ftable) 1; = Checkrp(ExP,, viable.fiable) if n=intandn=int then int else error(); int Expy < Expy | 1y = Checkrg(Exp) viable. fiable) 1) = Checkp (Exps, viable.fiable) i n=n then bool else error(); bool it B 11 = Checkrp(Exp, viable.fiable) thenExp, | 12 = Chieckiy (Expy, viable.fiable) else Exps 13 = Checkr(Exps, viable. fiable) if 1 = bool andt =1y then 1y clse error0;n W (Eps) | 1= lookup(fiable, gemame(id)) if 1= unbound then error(); int else (M) = 1o} =1 1 14] = Checkeys(Exps, viable. fiable) if m=nand ti =1 =1, shen 1y else error0: , let id = Expy | ) = Checkep(Exp, , vtable.fiable) in E viable' = bind(viable,getame(id),11) Checkey(Exp>, viablefiable) CheckrÂ»(Exps. vable.fiable) = case Exps of Ep | Checkr(Exp, viable.ftable)) Exp, Exps | Checkewp(Ep, vable.ftable) : Checkr.p;(Exps, viable.fiable)","libVersion":"0.3.2","langs":"dan+eng"}